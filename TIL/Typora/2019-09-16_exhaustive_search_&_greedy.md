## 2. 완전검색 & 그리디

### 반복(Iteration)과 재귀(Recursion)

- 반복과 재귀는 유사한 작업을 수핼할 수 있다.



- 반복은 수행하는 작업이 완료될 때까지 계속 반복
  - 루프(for, while 구조) 

> 명확한 반복 회수를 알 경우 for,  상태가 목적인 경우 while을 사용함



- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
  - 하나의 큰 문제를 해결할 수 있는 (해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합한다.
  - 재귀 함수로 구현



- 반복 구조
  - 초기화 (loop Initializtion)
    - 반복되는 명령문을 싱행하기 전에 (한 번만) 조건 검사에 사용할 변수의 초기값 설정
  - 조건검사 (check control expression)
  - 반복할 명령문 실행 (action)
  - 업데이트 (loop update)
    - 무한 루프(infinite loop)가 되지 않게 조건이 거짓(false)이 되게 한다.

![Iteration_rescue](.\image\Iteration_rescue.PNG)

- 재귀 함수(recursive function)
  - 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수.
  - 일반적으로 재귀적 정의릘 이용해서 재귀 함수를 구현한다.
  - 따라서, 기본 부분(basis part)와 유도 파트(inductive part)로 구성된다.
  - 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉽다.
    - 그러나, 재귀에 대해 익숙하지 않은 개발자들은 재귀적 프로그램이 어렵다고 느낀다.
  - 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다. 따라서 ㅐ귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하가 발생한다.

![factorial_recursive](.\image\factorial_recursive.PNG)



### 반복 또는 재귀?

- 해결할 문제를 고려해서 반복이나 재귀의 방법을 서택
- 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스럽다
  - 추상 자료형(List, tree 등)의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많다.

- 일반적으로, 재귀적 알고리즘은 반복(Iterative) 알고리즘보다 더 많은 메모리와 연산을 필요로 한다.
- **입력 값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.**



### 반복과  재귀

![Iteration&Recursion](.\image\Iteration&Recursion.PNG)

![Iteration&Recursion_2](.\image\Iteration&Recursion_2.PNG)





### 고지식한 방법(brute-force)

- brute-force는 문제를 해결하기 위한 간단하고 쉬운 접근법이다.
  - force의 이미는 사람(지능)보다는 컴퓨터이ㅡ force를 의미
- 대부분의 문제에 적용이 가능하다.
- 상대적으로 빠른 시간에 문제해결(알고리즘 설계)을 할 수 있다.
- 문제에 포함된(요소, 인스턴스)의 크기가  작다면 유용하다.
- 학술적 또는 교육적 목절을 위해 알고리즘의 효율성을 판단하기 위한 처도로 사용됨

- 모든 경우의 수를 생성하고 테스트 하기 떄문에 수행속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.



### 순열(Permutation)

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열한는 것
- 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다

$$
nPr
$$

- 그리고 nPr은 다음과 같은 식이 성립한다.

$$
nPr = x*(n-1)*(n-2)*... *(n-r+1)
$$

- nPn = n! 로 표기하며 Factorial이라 부른다.

$$
n! = n*(n-1)*(n-2)*...*2*1
$$











