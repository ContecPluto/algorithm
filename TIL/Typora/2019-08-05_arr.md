# 2019-08-05

슬라이딩 윈도우 : 배열의 연속적인구간을 왼쪽에서 오른쪽으로 움직이면서 문제를 해결하는 방법

1. Sum = 첫번째구간 (0 - M + 1)



2. Sum = 두번째 구간 

Sum = Sum - A + B

의 방식으로 구면 빠름

```python
N, M = map(int, input().split())
arr =list(map(int, input().split()))

Sum = 0
for i in range(M):
    Sum += arr[i]

Min = Max = Sum

for i in range(N - M + 1):
    Sum += (arr[i+M]) - arr[i])
    Min = min(Min, Sum)
    Max = max(Max, Sum)

print('#{} {}',(test_case, Max - Min))
```

기존의 방식대로 3개씩 더하면 숫자가 클떄 속도등이 낭비됨.



## 비트연산자

&      비트단위로 and 연산자

|		비트 단위로 or 연산자

`<<`	피연산자의 비트 열을 왼쪾으로 이동시킨다.

`>>` 	피연산자의 비트 열을 오른쪽으로 이동시킨다.



a =  10

b =  a&1

비트연사자로인해 홀수 판단을함

| 8    | 4    | 2    | 1    |
| ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | 0    |

1이 있다면 1이 없다면 0이 출력된다.

> 만약 a&8을 햇을경우에는 8이 출력된다. 즉 a&n 을 햇을경우 2진수로 n이 존재한다면 8이 출력된다.
>
> 따라서 1이 있다면 1이 출력된다. 없다면 0이 출력된다. 이를 이용해 if문을 이용하여 홀수 짝수를 판단할 수 있습니다.



a<<1

| 16   | 8    | 4    | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | 0    | 0    |



보다 간결한 부분집합 

```python
arr = [3,6,7,1,5,4]
N= len(arr)  #n : 원소의 개수

for subset in range(1 << N): #1<<n : 부분 집합의 개수
    print(subset, end = '>') # 원소의 수만큼 비트를 비교함
    for j in range(N): 	 	# i의 j번째 비트가 1이면 j번째 원소 출력
        if subset & (1 <<j):
            print(arr[j], end=' ')
    print()
```



## 이진 검색

자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법

- 목적 키를 찾을 떄까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여간다.
- 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.



#### 검색과정

1. 자료의 중앙에 있는 원소를 고른다
2. 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.
3. 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을  수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행한다.
4. 목표 값을 찾을 때까지 1~3을 반복한다.



#### 이진검색으로 7과 20을 찾는경우

|  2   |  4   |  7   |  9   |  11  |  19  |  23  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |  2   |  3   |  1   |      |      |      |
|      |      |      |  1   |      |  2   |  3   |

- 7의 경우

중앙값 9를 기준으로 7은 9보다 작으니 왼쪽 반에 대해서 새로 검색을 수행합니다. 

=>  다음 중간값 4 

 => 다음 중간값인 7 

일련의 과정을 통해 7=7 검색에 성공하였다.



- 20의 경우

중앙값 9를 기준으로 20은 9보다 크니 오른쪽 반에 대해서 새로이 검색을 수행합니다.

=> 19 => 23 의 과정을 거쳐 20은 존재하지않아 검색에 실패를 하였습니다.



## 인덱스

- 인덱스라는 용어는 database에서 유래했으며, 테이블에 대하 동작 속도를 높여주는 자료 구조를 일컫는다.

- 인덱스를 저장하는데 필요한 디스크 공간은 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다. 왜냐하면 보통 인덱스는 키-필드만 갖고 있고, 테이블의 다른 세부 항목들은 갖고 있지 않기 때문이다.
- 배열을 사용한 인덱스
  - 대략의 데이터를 매번 정렬하면, 프로그램의반응은 느려질 수 밖에 없다. 이러한 대량 데이터의 성능 저하 문제를 해결하기 위해 배열 인덱스를 사용한다.



- 다음 예에서 원본 데이터 배열과 별개로, 배열 인덱스를 추가한 예를 보여주고 있다.![index](.\image\index.PNG)

- 원본 데이터에 데이터가 삽입될 경우 상대적으로 크기가 작은 인덱스 배열을 정렬하기 떄문에 속도가 빠르다.



### 셀력션 알고리즘

- 저장되어 있는 자료로 부터 k번쨰 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 한다.
  - 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 한다.



- 선태과정
  - 1)정렬 알고리즘을 이용 자료정렬
  - 2)원하는 순서에 있는 원소 가져오기





## 선택 정렬(Selection_Sort)

가장 작은 숫자부터 골라서 차례대로 정리하는것이 선택 정렬이다.



- 주어진 자료들중 가작 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
  - 앞서 살펴본 셀렉션 알고리즘을 전체 자료에 적용한 것이다.



- 정렬 과정
  - 주어진 리스트 중에서 최소값을 찾는다.
  - 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
  - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.



- 시간 복잡도
  - O(n^2)



```python
#셀렉션 정렬
arr = [64, 25, 10, 22, 11]
N = len(arr)
#[0, n-1] 최솟값의 위치를 찾는다
minIdx = 0

for j in range(minIdx + 1, N):
    if arr[minIdx] > arr[j]:
        arr[0], arr[minIdx] = arr[minIdx], arr[0]

#[1, n-1]
minIdx = 1
for j in range(minIdx + 1, N):
    if arr[minIdx] > arr[j]:
        arr[0], arr[minIdx] = arr[minIdx], arr[0]

#[2, n-1]
#...
#[n-2, n-1]

```

```python
# 반복문 버전
for i in range(N - 1):
    minIdx = i
    for j in range(i + 1, N):
        if arr[minIdx] > arr[j]:
            minIdx = j
    arr[i], arr[minIdx] = arr[minIdx], arr[i]
print(arr)


#셀렉션 알고리즘 응용가능
#저장되어 있는 자료로부터 k번쨰로 큰 혹은 작은 원소를 찾는 방법( N = k)
#print(arr[k-1])
```



